# Database Changes

## Version 0.1.0
### Data Model
- Account
  - id
  - name
  - balance
- Transaction
  - id
  - name
  - amount
  - date
  - type
  - frequency
  - accountId
- Category
  - id
  - name
- AppliedTransaction
  - id
  - date
  - amount
  - type
  - transactionId
  - isManuallyUpdated

## Version 0.2.0
### Data Model
- Account
- Transaction
  - id
  - name
  - amount
  - date
  - type
  - frequency
  - accountId
  - categoryId
  - transactionId
- Category
  - id
  - name
  
âœ˜ AppliedTransaction 

### Why?
Kurt: There are changes in the database. from version 1 to 2, AppliedTransaction is removed because it is a semi-redundant table. In version 2, a Transaction can have 0 or more transaction children which is the function of the AppliedTransaction table. If a Transaction record doesn't have a transaction parent or a transactionId, then it is the parent, otherwise if the transaction has a transactionId, then it is a child transaction generated by the parent transaction. Do these changes in Transaction reflect the features of the deleted AppliedTransaction?

Another function for this is manual changes to a child Transaction. Changing the name or balance of a child Transaction causes it to become its own parent Transaction, which means transcationId is undefined, making it an independent Transaction which cannot be affected by the previous parent Transaction when there are changes to itself, so that only the child transactions of the previous parent Transaction are affected and not the 'manually updated' transaction is not. Would this work?

#### ChatGPT
Yes, the changes in the Transaction model to include a transactionId field can reflect the features of the deleted AppliedTransaction table. By using the transactionId field, you can establish a parent-child relationship between transactions, where a parent transaction can generate multiple child transactions.

#### Updated 

Transaction Interface
```typescript
interface Transaction {
  id?: number;
  name: string;
  amount: number; // decimal
  date: Date;
  type: TransactionType; // 0 = expense, 1 = income
  frequency: Frequency; // 0 = one-time, 1 = daily, 2 = weekly, 3 = monthly
  accountId: number; // foreign key
  categoryId?: number; // foreign key
  transactionId?: number; // foreign key to parent transaction
}
```

#### Handling Manual Changes

To handle manual changes to a child transaction, you can implement logic to check if a child transaction is manually updated. If a child transaction is manually updated, it should become an independent transaction (i.e., its transactionId should be set to `undefined`).

### Example Implementation
#### Updating a Transaction

```typescript
async function updateTransaction(transaction: Transaction): Promise<void> {
  return FinanceTrackerDatabase.transaction('rw', FinanceTrackerDatabase.transactions, async () => {
    const existingTransaction = await FinanceTrackerDatabase.transactions.get(transaction.id);
    if (!existingTransaction) {
      throw new Error(`Transaction with ID ${transaction.id} not found`);
    }

    // Check if the transaction is a child and has been manually updated
    if (existingTransaction.transactionId && (existingTransaction.name !== transaction.name || existingTransaction.amount !== transaction.amount)) {
      // Make it an independent transaction
      transaction.transactionId = undefined;
    }

    await FinanceTrackerDatabase.transactions.update(transaction.id, transaction);
  });
}
```

#### Querying Child Transactions

To get all child transactions of a parent transaction, you can query the transactions table where transactionId matches the parent's id.

#### Updated Database Schema

The updated database schema in db.model.ts would look like this:
```typescript
const FinanceTrackerDatabase = new Dexie("FinanceTrackerApp") as Dexie & {
  accounts: EntityTable<Account, 'id'>;
  transactions: EntityTable<Transaction, 'id'>;
  categories: EntityTable<Category, 'id'>;
};

FinanceTrackerDatabase.version(2).stores({
  accounts: "++id, name, balance",
  transactions: "++id, name, amount, date, type, frequency, accountId, categoryId, transactionId",
  categories: "++id, name",
});

export type { Account, Transaction, Category };
export default FinanceTrackerDatabase;
```

### Summary
AppliedTransaction table is redundant and adds unnecessary space to the database and complicates logic. It is thus removed and Transaction table will be used for child transaction, with transactionId field being used to judge whether a transaction is a parent transaction or a child transaction.

More importantly, every function of the AppliedTransaction table will be successfully kept, allowing cascade UD (updates and deletions) when parent transaction is mutated.

## Version 0.3.0
### Data Model
- Account
- Transaction
  - id
  - name
  - amount
  - date
  - type
  - frequency
  - accountId
  - categoryId
  - transactionId
- Category
  - id
  - name
  - color

### Reason
The current category model only allows separation of transactions by different category name which lowers user experience since categories cannot be visualized through color and only by name. Another effect of name-only categories would be that analytics services will have limited ways of visualizing categories.

That is why:
- Adding color to the category model allows analytics services to visualize transactions via categories.
- It also allows users to customize the color of their categories, leading to greater user experiences.

## Version 0.4.0
### Data Model
- Account
  - id
  - name
  - balance
  - startingBalance
  - createdAt
  - updatedAt
- Transaction
- Category

### Reason | Why?
Account is a simple model. An id, name, and balance. However, statistics need more than that. They need a sort of starting balance for comparison between dates. They also need to have several date fields to determine when was it created, when was it updated for analytics service to decide whether it is an old account or an active account.

That is why:
- Adding a starting balance will allow analytics modules to compared daily, weekly, monthly, and yearly data
- Adding a createdAt and updateAt date fields will allow analytics modules to determine the accounts age and whether it is an active account.

## Version 0.5.0
### Data Model
- Account
- Transaction
  - id
  - name
  - amount
  - date
  - type
  - frequency
  - status
  - accountId
  - categoryId
  - transactionId
- Category

### Reason | Why?
The current database structure lacks a way to track account balance history and transaction application states. This makes it difficult to:
1. Track balance changes over time
2. Rollback incorrect transactions
3. Verify transaction integrity
4. Track when transactions were actually applied to accounts

That is why I am:
- Adding status will allow us to track account balances changes by recording which transactions have been committed.
- Committing a transaction and changing the balance can be as easy as changing the transaction's status field and updating the account's balance field.
- Rolling back transaction commits can be as easy as getting the status field of the specific Transaction and doing a reverse calculation of the Account balance, afterward updating the status field or deleting the entire Transaction record.
- This enables better auditing and potential rollback features

## Version 0.6.0
### Data Model
- Account
- Transaction
  - id
  - name
  - amount
  - date
  - type
  - frequency
  - status
  - accountAmount
  - accountId
  - categoryId
  - transactionId
- Category

### Reason | Why?
The current database structure has a way to track which transaction has been committed, meaning that the transaction has changed its account's balance. This, however, does not allow account balance to be tracked reliably. This makes it difficult to track balance changes when date bounds are smaller or greater than a month.

It is possible to track monthly balance changes or even yearly balance changes, however, the calculations are immensely complex which would slow the application reducing user experience.

That is why adding **accountAmount**, which is the account's balance after the transaction has been committed, will allow balance changes to be tracked in any date bounds quickly and accurately.

However, this approach poses some challenges:
- **Potential extensive database update**: Any changes to older transactions will subsequently affect later transactions and lead to a large record update.
- **Potential Report Changes**: Any generated reports might have to be re-downloaded for more accurate data.

These challenges, however, as easy to mitigate by handing complex calculations to a web worker. Thus lowering the workload of the main thread.