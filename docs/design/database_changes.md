# Database Changes

## Version 0.1.0
### Data Model
- Account
  - id
  - name
  - balance
- Transaction
  - id
  - name
  - amount
  - date
  - type
  - frequency
  - accountId
- Category
  - id
  - name
- AppliedTransaction
  - id
  - date
  - amount
  - type
  - transactionId
  - isManuallyUpdated

## Version 0.2.0
### Data Model
- Account
- Transaction
  - id
  - name
  - amount
  - date
  - type
  - frequency
  - accountId
  - categoryId
  - transactionId
- Category
  - id
  - name
  
âœ˜ AppliedTransaction 

### Why?
Kurt: There are changes in the database. from version 1 to 2, AppliedTransaction is removed because it is a semi-redundant table. In version 2, a Transaction can have 0 or more transaction children which is the function of the AppliedTransaction table. If a Transaction record doesn't have a transaction parent or a transactionId, then it is the parent, otherwise if the transaction has a transactionId, then it is a child transaction generated by the parent transaction. Do these changes in Transaction reflect the features of the deleted AppliedTransaction?

Another function for this is manual changes to a child Transaction. Changing the name or balance of a child Transaction causes it to become its own parent Transaction, which means transcationId is undefined, making it an independent Transaction which cannot be affected by the previous parent Transaction when there are changes to itself, so that only the child transactions of the previous parent Transaction are affected and not the 'manually updated' transaction is not. Would this work?

#### ChatGPT
Yes, the changes in the Transaction model to include a transactionId field can reflect the features of the deleted AppliedTransaction table. By using the transactionId field, you can establish a parent-child relationship between transactions, where a parent transaction can generate multiple child transactions.

#### Updated 

Transaction Interface
```typescript
interface Transaction {
  id?: number;
  name: string;
  amount: number; // decimal
  date: Date;
  type: TransactionType; // 0 = expense, 1 = income
  frequency: Frequency; // 0 = one-time, 1 = daily, 2 = weekly, 3 = monthly
  accountId: number; // foreign key
  categoryId?: number; // foreign key
  transactionId?: number; // foreign key to parent transaction
}
```

#### Handling Manual Changes

To handle manual changes to a child transaction, you can implement logic to check if a child transaction is manually updated. If a child transaction is manually updated, it should become an independent transaction (i.e., its transactionId should be set to `undefined`).

### Example Implementation
#### Updating a Transaction

```typescript
async function updateTransaction(transaction: Transaction): Promise<void> {
  return FinanceTrackerDatabase.transaction('rw', FinanceTrackerDatabase.transactions, async () => {
    const existingTransaction = await FinanceTrackerDatabase.transactions.get(transaction.id);
    if (!existingTransaction) {
      throw new Error(`Transaction with ID ${transaction.id} not found`);
    }

    // Check if the transaction is a child and has been manually updated
    if (existingTransaction.transactionId && (existingTransaction.name !== transaction.name || existingTransaction.amount !== transaction.amount)) {
      // Make it an independent transaction
      transaction.transactionId = undefined;
    }

    await FinanceTrackerDatabase.transactions.update(transaction.id, transaction);
  });
}
```

#### Querying Child Transactions

To get all child transactions of a parent transaction, you can query the transactions table where transactionId matches the parent's id.

#### Updated Database Schema

The updated database schema in db.model.ts would look like this:
```typescript
const FinanceTrackerDatabase = new Dexie("FinanceTrackerApp") as Dexie & {
  accounts: EntityTable<Account, 'id'>;
  transactions: EntityTable<Transaction, 'id'>;
  categories: EntityTable<Category, 'id'>;
};

FinanceTrackerDatabase.version(2).stores({
  accounts: "++id, name, balance",
  transactions: "++id, name, amount, date, type, frequency, accountId, categoryId, transactionId",
  categories: "++id, name",
});

export type { Account, Transaction, Category };
export default FinanceTrackerDatabase;
```

### Summary
AppliedTransaction table is redundant and adds unnecessary space to the database and complicates logic. It is thus removed and Transaction table will be used for child transaction, with transactionId field being used to judge whether a transaction is a parent transaction or a child transaction.

More importantly, every function of the AppliedTransaction table will be successfully kept, allowing cascade UD (updates and deletions) when parent transaction is mutated.

## Version 0.3.0
### Data Model
- Account
- Transaction
  - id
  - name
  - amount
  - date
  - type
  - frequency
  - accountId
  - categoryId
  - transactionId
- Category
  - id
  - name
  - color

### Reason
The current category model only allows separation of transactions by different category name which lowers user experience since categories cannot be visualized through color and only by name. Another effect of name-only categories would be that analytics services will have limited ways of visualizing categories.

That is why:
- Adding color to the category model allows analytics services to visualize transactions via categories.
- It also allows users to customize the color of their categories, leading to greater user experiences.

## Version 0.4.0
### Data Model
- Account
  - id
  - name
  - balance
  - startingBalance
  - createdAt
  - updatedAt
- Transaction
- Category

### Reason | Why?
Account is a simple model. An id, name, and balance. However, statistics need more than that. They need a sort of starting balance for comparison between dates. They also need to have several date fields to determine when was it created, when was it updated for analytics service to decide whether it is an old account or an active account.

That is why:
- Adding a starting balance will allow analytics modules to compared daily, weekly, monthly, and yearly data
- Adding a createdAt and updateAt date fields will allow analytics modules to determine the accounts age and whether it is an active account.
